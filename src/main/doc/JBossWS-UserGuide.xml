<?xml version="1.0" encoding="UTF-8"?><chapter id="chap_JBossWS-UserGuide"><title>JBossWS-UserGuide</title><para/>
<section id="JBossWS-UserGuide_Common_User_Guide"><title>Common User Guide</title><para> </para><para>Here below is the documentation that applies to every supported stacks. This includes basic JAX-WS usage as well as references to common additional functionalities the JBossWS Web Service Framework provides on top of the supported stacks.</para><section id="JBossWS-UserGuide_Web_Service_Concepts"><title>Web Service Concepts</title><section id="JBossWS-UserGuide_DocumentLiteral"><title>Document/Literal</title><para>With document style web services two business partners agree on the exchange of complex business documents that are well defined in XML schema. For example, one party sends a document describing a purchase order, the other responds (immediately or later) with a document that describes the status of the purchase order. No need to agree on such low level details as operation names and their associated parameters.</para><para>The payload of the SOAP message is an XML document that can be validated against XML schema.</para><para>Document is defined by the style attribute on the SOAP binding.</para><screen xml:space="preserve"> &lt;binding name='EndpointInterfaceBinding' type='tns:EndpointInterface'&gt;
  &lt;soap:binding style='document' transport='<ulink url="http://schemas.xmlsoap.org/soap/http'/">http://schemas.xmlsoap.org/soap/http'/</ulink>&gt;
  &lt;operation name='concat'&gt;
   &lt;soap:operation soapAction=''/&gt;
   &lt;input&gt;
    &lt;soap:body use='literal'/&gt;
   &lt;/input&gt;
   &lt;output&gt;
    &lt;soap:body use='literal'/&gt;
   &lt;/output&gt;
  &lt;/operation&gt;&lt;/binding&gt;
</screen><para>With document style web services the payload of every message is defined by a complex type in XML schema.</para><screen xml:space="preserve">   &lt;complexType name='concatType'&gt;
    &lt;sequence&gt;
     &lt;element name='String_1' nillable='true' type='string'/&gt;
     &lt;element name='long_1' type='long'/&gt;
    &lt;/sequence&gt;
   &lt;/complexType&gt;
   &lt;element name='concat' type='tns:concatType'/&gt;
</screen><para>Therefore, message parts <emphasis role="bold">must</emphasis> refer to an <emphasis role="bold">element</emphasis> from the schema.</para><screen xml:space="preserve"> &lt;message name='EndpointInterface_concat'&gt;
  &lt;part name='parameters' element='tns:concat'/&gt;&lt;/message&gt;
</screen><para>The following message definition <emphasis role="bold">is invalid</emphasis>.</para><screen xml:space="preserve"> &lt;message name='EndpointInterface_concat'&gt;
  &lt;part name='parameters' type='tns:concatType'/&gt;&lt;/message&gt;</screen><section id="JBossWS-UserGuide_DocumentLiteral_Bare"><title>Document/Literal (Bare)</title><para>Bare is an implementation detail from the Java domain. Neither in the abstract contract (i.e. wsdl+schema) nor at the SOAP message level is a bare endpoint recognizable.</para><para>A bare endpoint or client uses a Java bean that represents the entire document payload.</para><screen xml:space="preserve">@WebService
@SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> DocBareServiceImpl
{
   @WebMethod
   <emphasis role="bold">public</emphasis> SubmitBareResponse submitPO(SubmitBareRequest poRequest)
   {
      ...
   }
}
</screen><para>The trick is that the Java beans representing the payload contain JAXB annotations that define how the payload is represented on the wire.</para><screen xml:space="preserve">@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "SubmitBareRequest", namespace="<ulink url="http://soapbinding.samples.jaxws.ws.test.jboss.org/">http://soapbinding.samples.jaxws.ws.test.jboss.org/</ulink>", propOrder = { "product" })
@XmlRootElement(namespace="<ulink url="http://soapbinding.samples.jaxws.ws.test.jboss.org/">http://soapbinding.samples.jaxws.ws.test.jboss.org/</ulink>", name = "SubmitPO")
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> SubmitBareRequest
{
   @XmlElement(namespace="<ulink url="http://soapbinding.samples.jaxws.ws.test.jboss.org/">http://soapbinding.samples.jaxws.ws.test.jboss.org/</ulink>",  required = <emphasis role="bold">true</emphasis>)
   <emphasis role="bold">private</emphasis> String product;
   
   ...
}
</screen></section>
<section id="JBossWS-UserGuide_DocumentLiteral_Wrapped"><title>Document/Literal (Wrapped)</title><para>Wrapped is an implementation detail from the Java domain. Neither in the abstract contract (i.e. wsdl+schema) nor at the SOAP message level is a wrapped endpoint recognizable.</para><para>A wrapped endpoint or client uses the individual document payload properties. Wrapped is the default and does not have to be declared explicitly.</para><screen xml:space="preserve">@WebService
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> DocWrappedServiceImpl
{
   @WebMethod
   @RequestWrapper (className="org.somepackage.SubmitPO")
   @ResponseWrapper (className="org.somepackage.SubmitPOResponse")
   <emphasis role="bold">public</emphasis> String submitPO(String product, <emphasis role="bold">int</emphasis> quantity)
   {
      ...
   }
}
</screen><para>Note, that with JBossWS the request/response wrapper annotations are <emphasis role="bold">not required</emphasis>, they will be generated on demand using sensible defaults.</para><para> </para></section>
</section>
<section id="JBossWS-UserGuide_RPCLiteral"><title>RPC/Literal</title><para>With RPC there is a wrapper element that names the endpoint operation. Child elements of the RPC parent are the individual parameters.</para><para>The SOAP body is constructed based on some simple rules:</para><itemizedlist><listitem><para> The port type operation name defines the endpoint method name </para></listitem><listitem><para> Message parts are endpoint method parameters </para></listitem></itemizedlist><para>RPC is defined by the style attribute on the SOAP binding.</para><screen xml:space="preserve"> &lt;binding name='EndpointInterfaceBinding' type='tns:EndpointInterface'&gt;
  &lt;soap:binding style='rpc' transport='<ulink url="http://schemas.xmlsoap.org/soap/http'/">http://schemas.xmlsoap.org/soap/http'/</ulink>&gt;
  &lt;operation name='echo'&gt;
   &lt;soap:operation soapAction=''/&gt;
   &lt;input&gt;
    &lt;soap:body namespace='<ulink url="http://org.jboss.ws/samples/jsr181pojo">http://org.jboss.ws/samples/jsr181pojo</ulink>' use='literal'/&gt;
   &lt;/input&gt;
   &lt;output&gt;
    &lt;soap:body namespace='<ulink url="http://org.jboss.ws/samples/jsr181pojo">http://org.jboss.ws/samples/jsr181pojo</ulink>' use='literal'/&gt;
   &lt;/output&gt;
  &lt;/operation&gt;&lt;/binding&gt;
</screen><para>With rpc style web services the portType names the operation (i.e. the java method on the endpoint)</para><screen xml:space="preserve"> &lt;portType name='EndpointInterface'&gt;
  &lt;operation name='echo' parameterOrder='String_1'&gt;
   &lt;input message='tns:EndpointInterface_echo'/&gt;
   &lt;output message='tns:EndpointInterface_echoResponse'/&gt;
  &lt;/operation&gt;&lt;/portType&gt;
</screen><para>Operation parameters are defined by individual message parts.</para><screen xml:space="preserve"> &lt;message name='EndpointInterface_echo'&gt;
  &lt;part name='String_1' type='xsd:string'/&gt;&lt;/message&gt;&lt;message name='EndpointInterface_echoResponse'&gt;
  &lt;part name='result' type='xsd:string'/&gt;&lt;/message&gt;
</screen><para>Note, there is no complex type in XML schema that could validate the entire SOAP message payload.</para><screen xml:space="preserve">@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> JSEBean01
{
   @WebMethod
   @WebResult(name="result")
   <emphasis role="bold">public</emphasis> String echo(@WebParam(name="String_1") String input)
   {
      ...
   }
}
</screen><para>The element names of RPC parameters/return values may be defined using the JAX-WS <link linkend="chap_JBossWS-JAX-WSAnnotations">WebParam</link> and <link linkend="chap_JBossWS-JAX-WSAnnotations">WebResult</link> annotations respectively.</para></section>
<section id="JBossWS-UserGuide_RPCEncoded"><title>RPC/Encoded</title><para>SOAP encodeding style is defined by the infamous <ulink url="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383512">chapter 5</ulink> of the <ulink url="http://www.w3.org/TR/2000/NOTE-SOAP-20000508">SOAP-1.1</ulink> specification. <emphasis role="bold">It has inherent interoperability issues</emphasis> that cannot be fixed. The <ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html">Basic Profile-1.0</ulink> prohibits this encoding style in <ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html#refinement16448072">4.1.7 SOAP encodingStyle Attribute</ulink>.</para><para> JBossWS doesn't support rpc/encoded anymore.</para><para> </para></section>
</section>
<section id="JBossWS-UserGuide_Web_Service_Endpoints"><title>Web Service Endpoints</title><para>JAX-WS simplifies the development model for a web service endpoint a great deal. In short, an endpoint implementation bean is annotated with JAX-WS annotations and deployed to the server. The server automatically generates and publishes the abstract contract (i.e. wsdl+schema) for client consumption. All marshalling/unmarshalling is delegated to JAXB.</para><para> </para><section id="JBossWS-UserGuide_Plain_old_Java_Object_POJO"><title>Plain old Java Object (POJO)</title><para>Let's take a look at simple POJO endpoint implementation. All endpoint associated metadata is provided via JSR-181 annotations</para><screen xml:space="preserve">    @WebService
    @SOAPBinding(style = SOAPBinding.Style.RPC)
    <emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> JSEBean01
    {
       @WebMethod
       <emphasis role="bold">public</emphasis> String echo(String input)
       {
          ...
       }
    }
</screen><para><emphasis role="bold">The endpoint as a web application</emphasis></para><para>A JAX-WS java service endpoint (JSE) is deployed as a web application.</para><screen xml:space="preserve">  &lt;web-app ...&gt;
    &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
  &lt;/web-app&gt;
</screen><para><emphasis role="bold">Packaging the endpoint</emphasis></para><para>A JSR-181 java service endpoint (JSE) is packaged as a web application in a *.war file.</para><screen xml:space="preserve">    &lt;war warfile="${build.dir}/libs/jbossws-samples-jsr181pojo.war" webxml="${build.resources.dir}/samples/jsr181pojo/WEB-INF/web.xml"&gt;
      &lt;classes dir="${build.dir}/classes"&gt;
        &lt;include name="org/jboss/test/ws/samples/jsr181pojo/JSEBean01.class"/&gt;
      &lt;/classes&gt;
    &lt;/war&gt;
</screen><para>Note, only the endpoint implementation bean and web.xml are required.</para><para><emphasis role="bold">Accessing the generated WSDL</emphasis></para><para>A successfully deployed service endpoint will show up in the service endpoint manager. This is also where you find the links to the generated wsdl.</para><screen xml:space="preserve">   http://yourhost:8080/jbossws/services
</screen><para>Note, it is also possible to generate the abstract contract off line using jbossw tools. For details of that please see <link linkend="chap_JBossWS-JAX-WSTools">Bottom-Up (Java to WSDL)</link></para><para> </para></section>
<section id="JBossWS-UserGuide_EJB3_Stateless_Session_Bean_SLSB"><title>EJB3 Stateless Session Bean (SLSB)</title><para>The JAX-WS programming model support the same set of annotations on EJB3 stateless session beans as on <link linkend="JBossWS-UserGuide_Plain_old_Java_Object_POJO">Plain old Java Object (POJO)</link> endpoints.  EJB-2.1 endpoints are supported using the JAX-RPC progamming model (with JBossWS-Native only).</para><screen xml:space="preserve">    @Stateless
    @Remote(EJB3RemoteInterface.class)
    @RemoteBinding(jndiBinding = "/ejb3/EJB3EndpointInterface")
 
    @WebService
    @SOAPBinding(style = SOAPBinding.Style.RPC)
    <emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> EJB3Bean01 <emphasis role="bold">implements</emphasis> EJB3RemoteInterface
    {
       @WebMethod
       <emphasis role="bold">public</emphasis> String echo(String input)
       {
          ...
       }
    }
</screen><para>Above you see an EJB-3.0 stateless session bean that exposes one method both on the remote interface and on and as an endpoint operation.</para><para><emphasis role="bold">Packaging the endpoint</emphasis></para><para>A JSR-181 EJB service endpoint is packaged as an ordinary ejb deployment.</para><screen xml:space="preserve">    &lt;jar jarfile="${build.dir}/libs/jbossws-samples-jsr181ejb.jar"&gt;
      &lt;fileset dir="${build.dir}/classes"&gt;
        &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3Bean01.class"/&gt;
        &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3RemoteInterface.class"/&gt;
      &lt;/fileset&gt;
    &lt;/jar&gt;
</screen><para><emphasis role="bold">Accessing the generated WSDL</emphasis></para><para>A successfully deployed service endpoint will show up in the service endpoint manager. This is also where you find the links to the generated wsdl.</para><screen xml:space="preserve">   http://yourhost:8080/jbossws/services
</screen><para>Note, it is also possible to generate the abstract contract off line using jbossw tools. For details of that please see <link linkend="chap_JBossWS-JAX-WSTools">Bottom-Up (Java to WSDL)</link></para><para> </para></section>
<section id="JBossWS-UserGuide_Endpoint_Provider"><title>Endpoint Provider</title><para>JAX-WS services typically implement a native Java service endpoint interface (SEI), perhaps mapped from a WSDL port type, either directly or via the use of annotations.</para><para>Java SEIs provide a high level Java-centric abstraction that hides the details of converting between Java objects and their XML representations for use in XML-based messages. However, in some cases it is desirable for services to be able to operate at the XML message level. The Provider interface offers an alternative to SEIs and may be implemented by services wishing to work at the XML message level.</para><para>A Provider based service instances invoke method is called for each message received for the service.</para><screen xml:space="preserve">   @WebServiceProvider(wsdlLocation = "WEB-INF/wsdl/Provider.wsdl")
   @ServiceMode(value = Service.Mode.PAYLOAD)
   <emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> ProviderBeanPayload <emphasis role="bold">implements</emphasis> Provider&lt;Source&gt;
   {
      <emphasis role="bold">public</emphasis> Source invoke(Source req)
      {
         // Access the entire request PAYLOAD and return the response PAYLOAD
      }
   }
</screen><para>Note, Service.Mode.PAYLOAD is the default and does not have to be declared explicitly. You can also use Service.Mode.MESSAGE to access the entire SOAP message (i.e. with MESSAGE the Provider can also see SOAP Headers)</para><para>The abstract contract for a provider endpoint cannot be derived/generated automatically. Therefore it is necessary to specify the wsdlLocation with the @WebServiceProvider annotation.</para><para> </para></section>
<section id="JBossWS-UserGuide_WebServiceContext"><title>WebServiceContext</title><para>The WebServiceContext is treated as an injectable resource that can be set at the time an endpoint is initialized. The WebServiceContext object will then use thread-local information to return the correct information regardless of how many threads are concurrently being used to serve requests addressed to the same endpoint object.</para><screen xml:space="preserve">   @WebService
   <emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> EndpointJSE
   {
      @Resource
      WebServiceContext wsCtx;
   
      @WebMethod
      <emphasis role="bold">public</emphasis> String testGetMessageContext()
      {
         SOAPMessageContext jaxwsContext = (SOAPMessageContext)wsCtx.getMessageContext();
         <emphasis role="bold">return</emphasis> jaxwsContext != <emphasis role="bold">null</emphasis> ? "pass" : "fail";
      }
   
      @WebMethod
      <emphasis role="bold">public</emphasis> String testGetUserPrincipal()
      {
         Principal principal = wsCtx.getUserPrincipal();
         <emphasis role="bold">return</emphasis> principal.getName();
      }
   
      @WebMethod
      <emphasis role="bold">public</emphasis> <emphasis role="bold">boolean</emphasis> testIsUserInRole(String role)
      {
         <emphasis role="bold">return</emphasis> wsCtx.isUserInRole(role);
      }
   }
</screen><para> </para><para> </para><para> </para></section>
</section>
<section id="JBossWS-UserGuide_Web_Service_Clients"><title>Web Service Clients</title><section id="JBossWS-UserGuide_Service"><title>Service</title><para><computeroutput>Service</computeroutput> is an abstraction that represents a WSDL service. A WSDL service is a collection of related ports, each of which consists of a port type bound to a particular protocol and available at a particular endpoint address.</para><para>For most clients, you will start with a set of stubs generated from the WSDL. One of these will be the service, and you will create objects of that class in order to work with the service (see "static case" below).</para><section id="JBossWS-UserGuide_Service_Usage"><title>Service Usage</title><para><emphasis role="bold">Static case</emphasis></para><para>Most clients will start with a WSDL file, and generate some stubs using jbossws tools like <emphasis>wsconsume</emphasis>.  This usually gives a mass of files, one of which is the top of the tree.  This is the service implementation class.</para><para>The generated implementation class can be recognised as it will have two public constructors, one with no arguments and one with two arguments, representing the wsdl location (a java.net.URL) and the service name (a javax.xml.namespace.QName) respectively.</para><para>Usually you will use the no-argument constructor. In this case the WSDL location and service name are those found in the WSDL. These are set implicitly from the WebServiceClient annotation that decorates the generated class.</para><para>The following code snippet shows the generated constructors from the generated class:</para><screen xml:space="preserve">// Generated Service Class
 
@WebServiceClient(name="StockQuoteService", targetNamespace="<ulink url="http://example.com/stocks">http://example.com/stocks</ulink>", wsdlLocation="<ulink url="http://example.com/stocks.wsdl">http://example.com/stocks.wsdl</ulink>")
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> StockQuoteService <emphasis role="bold">extends</emphasis> javax.xml.ws.Service 
{
   <emphasis role="bold">public</emphasis> StockQuoteService() 
   {
      <emphasis role="bold">super</emphasis>(<emphasis role="bold">new</emphasis> URL("<ulink url="http://example.com/stocks.wsdl">http://example.com/stocks.wsdl</ulink>"), <emphasis role="bold">new</emphasis> QName("<ulink url="http://example.com/stocks">http://example.com/stocks</ulink>", "StockQuoteService"));
   }
 
   <emphasis role="bold">public</emphasis> StockQuoteService(String wsdlLocation, QName serviceName) 
   {
      <emphasis role="bold">super</emphasis>(wsdlLocation, serviceName);
   }
 
   ...
}
</screen><para>Section <link linkend="JBossWS-UserGuide_Dynamic_Proxy">Dynamic Proxy</link> explains how to obtain a port from the service and how to invoke an operation on the port. If you need to work with the XML payload directly or with the XML representation of the entire SOAP message, have a look at <link linkend="JBossWS-UserGuide_Dispatch">Dispatch</link>.</para><para><emphasis role="bold">Dynamic case</emphasis></para><para>In the dynamic case, when nothing is generated, a web service client uses <computeroutput>Service.create</computeroutput> to create Service instances, the following code illustrates this process.</para><screen xml:space="preserve">   URL wsdlLocation = <emphasis role="bold">new</emphasis> URL("<ulink url="http://example.org/my.wsdl">http://example.org/my.wsdl</ulink>");
   QName serviceName = <emphasis role="bold">new</emphasis> QName("<ulink url="http://example.org/sample">http://example.org/sample</ulink>", "MyService");
   Service service = Service.create(wsdlLocation, serviceName);
</screen><para> </para><para> </para></section>
<section id="JBossWS-UserGuide_Handler_Resolver"><title>Handler Resolver</title><para>JAX-WS provides a flexible plug-in framework for message processing modules, known as handlers, that may be used to extend the capabilities of a JAX-WS runtime system. <link linkend="JBossWS-UserGuide_Handler_Framework">Handler Framework</link> describes the handler framework in detail. A Service instance provides access to a HandlerResolver via a pair of getHandlerResolver/setHandlerResolver methods that may be used to configure a set of handlers on a per-service, per-port or per-protocol binding basis.</para><para>When a Service instance is used to create a proxy or a Dispatch instance then the handler resolver currently registered with the service is used to create the required handler chain. Subsequent changes to the handler resolver configured for a Service instance do not affect the handlers on previously created proxies, or Dispatch instances.</para></section>
<section id="JBossWS-UserGuide_Executor"><title>Executor</title><para>Service instances can be configured with a java.util.concurrent.Executor. The executor will then be used to invoke any asynchronous callbacks requested by the application. The setExecutor and getExecutor methods of Service can be used to modify and retrieve the executor configured for a service.</para></section>
</section>
<section id="JBossWS-UserGuide_Dynamic_Proxy"><title>Dynamic Proxy</title><para>You can create an instance of a client proxy using one of getPort methods on the <link linkend="JBossWS-UserGuide_Service">Service</link>.</para><screen xml:space="preserve">   /** 
    * The getPort method returns a proxy. A service client
    * uses this proxy to invoke operations on the target
    * service endpoint. The &lt;code&gt;serviceEndpointInterface&lt;/code&gt;
    * specifies the service endpoint interface that is supported by
    * the created dynamic proxy instance.
    **/
   <emphasis role="bold">public</emphasis> &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
   {
      ...
   }
 
   /** 
    * The getPort method returns a proxy. The parameter
    * &lt;code&gt;serviceEndpointInterface&lt;/code&gt; specifies the service
    * endpoint interface that is supported by the returned proxy.
    * In the implementation of this method, the JAX-WS
    * runtime system takes the responsibility of selecting a protocol
    * binding (and a port) and configuring the proxy accordingly.
    * The returned proxy should not be reconfigured by the client.
    *
    **/
   <emphasis role="bold">public</emphasis> &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)
   {
      ...
   }
</screen><para>The service endpoint interface (SEI) is usually generated using tools. For details see <link linkend="chap_JBossWS-JAX-WSTools">Top Down (WSDL to Java)</link></para><para>A generated static <ulink url="http://community.jboss.org/Service">Service</ulink> usually also offers typed methods to get ports. These methods also return dynamic proxies that implement the SEI.</para><screen xml:space="preserve">@WebServiceClient(name = "TestEndpointService", targetNamespace = "<ulink url="http://org.jboss.ws/wsref">http://org.jboss.ws/wsref</ulink>", 
   wsdlLocation = "<ulink url="http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl">http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl</ulink>")
 
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> TestEndpointService <emphasis role="bold">extends</emphasis> Service
{
    ...
 
    <emphasis role="bold">public</emphasis> TestEndpointService(URL wsdlLocation, QName serviceName) {
        <emphasis role="bold">super</emphasis>(wsdlLocation, serviceName);
    }
 
    @WebEndpoint(name = "TestEndpointPort")
    <emphasis role="bold">public</emphasis> TestEndpoint getTestEndpointPort() 
    {
        <emphasis role="bold">return</emphasis> (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
    }
}
</screen><para> </para></section>
<section id="JBossWS-UserGuide_WebServiceRef"><title>WebServiceRef</title><para>The WebServiceRef annotation is used to declare a reference to a Web service. It follows the resource pattern exemplified by the javax.annotation.Resource annotation in JSR-250.</para><para>There are two uses to the WebServiceRef annotation:</para><orderedlist><listitem><para> To define a reference whose type is a generated service class. In this case, the type and value element will both refer to the generated service class type. Moreover, if the reference type can be inferred by the field/method declaration the annotation is applied to, the type and value elements MAY have the default value (Object.class, that is). If the type cannot be inferred, then at least the type element MUST be present with a non-default value. </para></listitem><listitem><para> To define a reference whose type is a SEI. In this case, the type element MAY be present with its default value if the type of the reference can be inferred from the annotated field/method declaration, but the value element MUST always be present and refer to a generated service class type (a subtype of javax.xml.ws.Service). The wsdlLocation element, if present, overrides theWSDL location information specified in the WebService annotation of the referenced generated service class. </para></listitem></orderedlist><screen xml:space="preserve"><emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> EJB3Client <emphasis role="bold">implements</emphasis> EJB3Remote
{
   @WebServiceRef
   <emphasis role="bold">public</emphasis> TestEndpointService service4;
 
   @WebServiceRef
   <emphasis role="bold">public</emphasis> TestEndpoint port3;
</screen><para><emphasis role="bold">WebServiceRef Customization</emphasis></para><para>Starting from jboss-5.0.x we offer a number of overrides and extensions to the WebServiceRef annotation. These include</para><itemizedlist><listitem><para> define the port that should be used to resolve a container-managed port </para></listitem><listitem><para> define default Stub property settings for Stub objects </para></listitem><listitem><para> define the URL of a final WSDL document to be used </para></listitem></itemizedlist><para>Example:</para><screen xml:space="preserve">  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;wsdl-override&gt;file:/wsdlRepository/organization-service.wsdl&lt;/wsdl-override&gt;
  &lt;/service-ref&gt;

  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;config-name&gt;Secure Client Config&lt;/config-name&gt;
   &lt;config-file&gt;META-INF/jbossws-client-config.xml&lt;/config-file&gt;
   &lt;handler-chain&gt;META-INF/jbossws-client-handlers.xml&lt;/handler-chain&gt;
  &lt;/service-ref&gt;
  
  &lt;service-ref&gt;
   &lt;service-ref-name&gt;SecureService&lt;/service-ref-name&gt;
   &lt;service-impl-class&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpointService&lt;/service-impl-class&gt;
   &lt;service-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointService&lt;/service-qname&gt;
    &lt;port-component-ref&gt;
     &lt;service-endpoint-interface&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpoint&lt;/service-endpoint-interface&gt;
     &lt;port-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointPort&lt;/port-qname&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;javax.xml.ws.security.auth.username&lt;/prop-name&gt;
      &lt;prop-value&gt;kermit&lt;/prop-value&gt;
     &lt;/stub-property&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;javax.xml.ws.security.auth.password&lt;/prop-name&gt;
      &lt;prop-value&gt;thefrog&lt;/prop-value&gt;
     &lt;/stub-property&gt;
   &lt;/port-component-ref&gt;
  &lt;/service-ref&gt;
</screen><para>For details please see <emphasis role="bold">service-ref_5_0.dtd</emphasis> in the jboss docs directory.</para><para> </para></section>
<section id="JBossWS-UserGuide_Dispatch"><title>Dispatch</title><para>XMLWeb Services use XML messages for communication between services and service clients. The higher level JAX-WS APIs are designed to hide the details of converting between Java method invocations and the corresponding XML messages, but in some cases operating at the XML message level is desirable. The Dispatch interface provides support for this mode of interaction.</para><para>Dispatch supports two usage modes, identified by the constants javax.xml.ws.Service.Mode.MESSAGE and javax.xml.ws.Service.Mode.PAYLOAD respectively:</para><para><emphasis role="bold">Message</emphasis> In this mode, client applications work directly with protocol-specific message structures. E.g., when used with a SOAP protocol binding, a client application would work directly with a SOAP message.</para><para><emphasis role="bold">Message Payload</emphasis> In this mode, client applications work with the payload of messages rather than the messages themselves. E.g., when used with a SOAP protocol binding, a client application would work with the contents of the SOAP Body rather than the SOAP message as a whole.</para><para>Dispatch is a low level API that requires clients to construct messages or message payloads as XML and requires an intimate knowledge of the desired message or payload structure. Dispatch is a generic class that supports input and output of messages or message payloads of any type.</para><screen xml:space="preserve">      Service service = Service.create(wsdlURL, serviceName);
      Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);
 
      String payload = "&lt;ns1:ping xmlns:ns1='<ulink url="http://oneway.samples.jaxws.ws.test.jboss.org/'/">http://oneway.samples.jaxws.ws.test.jboss.org/'/</ulink>&gt;";
      dispatch.invokeOneWay(<emphasis role="bold">new</emphasis> StreamSource(<emphasis role="bold">new</emphasis> StringReader(payload)));
 
      payload = "&lt;ns1:feedback xmlns:ns1='<ulink url="http://oneway.samples.jaxws.ws.test.jboss.org/'/">http://oneway.samples.jaxws.ws.test.jboss.org/'/</ulink>&gt;";
      Source retObj = (Source)dispatch.invoke(<emphasis role="bold">new</emphasis> StreamSource(<emphasis role="bold">new</emphasis> StringReader(payload)));
</screen></section>
<section id="JBossWS-UserGuide_Asynchronous_Invocations"><title>Asynchronous Invocations</title><para>The BindingProvider interface represents a component that provides a protocol binding for use by clients, it is implemented by proxies and is extended by the Dispatch interface.</para><para>BindingProvider instances may provide asynchronous operation capabilities. When used, asynchronous operation invocations are decoupled from the BindingProvider instance at invocation time such that the response context is not updated when the operation completes. Instead a separate response context is made available using the Response interface.</para><screen xml:space="preserve">   <emphasis role="bold">public</emphasis> <emphasis role="bold">void</emphasis> testInvokeAsync() <emphasis role="bold">throws</emphasis> Exception
   {
      URL wsdlURL = <emphasis role="bold">new</emphasis> URL("<ulink url="http://">http://</ulink>" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
      QName serviceName = <emphasis role="bold">new</emphasis> QName(targetNS, "TestEndpointService");
      Service service = Service.create(wsdlURL, serviceName);
      TestEndpoint port = service.getPort(TestEndpoint.class);
 
      Response response = port.echoAsync("Async");
 
      // access future
      String retStr = (String) response.get();
      assertEquals("Async", retStr);
   }
</screen></section>
<section id="JBossWS-UserGuide_Oneway_Invocations"><title>Oneway Invocations</title><para>@Oneway indicates that the given web method has only an input message and no output. Typically, a oneway method returns the thread of control to the calling application prior to executing the actual business method.</para><screen xml:space="preserve">@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> PingEndpointImpl
{
   <emphasis role="bold">private</emphasis> <emphasis role="bold">static</emphasis> String feedback;
   
   @WebMethod
   @Oneway
   <emphasis role="bold">public</emphasis> <emphasis role="bold">void</emphasis> ping()
   {
      log.info("ping");
      feedback = "ok";
   }
   
   @WebMethod
   <emphasis role="bold">public</emphasis> String feedback()
   {
      log.info("feedback");
      <emphasis role="bold">return</emphasis> feedback;
   }
}
</screen></section>
<section id="JBossWS-UserGuide_Oneway_Invocations_697545"><title>Timeout Configuration</title><para>There are two properties to configure the http connection timeout and client receive time out:</para><screen xml:space="preserve"> public void testConfigureTimeout() throws Exception    {   //Set timeout until a connection is established   ((BindingProvider) port).getRequestContext().          put("javax.xml.ws.client.connectionTimeout", "6000");  //Set timeout until the response is received         ((BindingProvider) port).getRequestContext().          put("javax.xml.ws.client.receiveTimeout", "1000");    port.echo("testTimeout");    }
</screen></section>
</section>
<section id="JBossWS-UserGuide_Common_API"><title>Common API</title><para>This sections describes concepts that apply equally to <link linkend="JBossWS-UserGuide_Web_Service_Endpoints">Web Service Endpoints</link> and <link linkend="JBossWS-UserGuide_Web_Service_Clients">Web Service Clients</link>.</para><section id="JBossWS-UserGuide_Handler_Framework"><title>Handler Framework</title><para>The handler framework is implemented by a JAX-WS protocol binding in both client and server side runtimes. Proxies, and Dispatch instances, known collectively as binding providers, each use protocol bindings to bind their abstract functionality to specific protocols.</para><para>Client and server-side handlers are organized into an ordered list known as a handler chain. The handlers within a handler chain are invoked each time a message is sent or received. Inbound messages are processed by handlers prior to binding provider processing. Outbound messages are processed by handlers after any binding provider processing.</para><para>Handlers are invoked with a message context that provides methods to access and modify inbound and outbound messages and to manage a set of properties. Message context properties may be used to facilitate communication between individual handlers and between handlers and client and service implementations. Different types of handlers are invoked with different types of message context.</para><section id="JBossWS-UserGuide_Logical_Handler"><title>Logical Handler</title><para>Handlers that only operate on message context properties and message payloads. Logical handlers are protocol agnostic and are unable to affect protocol specific parts of a message. Logical handlers are handlers that implement javax.xml.ws.handler.LogicalHandler.</para></section>
<section id="JBossWS-UserGuide_Protocol_Handler"><title>Protocol Handler</title><para>Handlers that operate on message context properties and protocol specific messages. Protocol handlers are specific to a particular protocol and may access and change protocol specific aspects of a message. Protocol handlers are handlers that implement any interface derived from javax.xml.ws.handler.Handler except javax.xml.ws.handler.LogicalHandler.</para></section>
<section id="JBossWS-UserGuide_Service_endpoint_handlers"><title>Service endpoint handlers</title><para>On the service endpoint, handlers are defined using the @HandlerChain annotation.</para><screen xml:space="preserve">@WebService
@HandlerChain(file = "jaxws-server-source-handlers.xml")
<emphasis role="bold">public</emphasis> <emphasis role="bold">class</emphasis> SOAPEndpointSourceImpl
{
   ...
}
</screen><para>The location of the handler chain file supports 2 formats</para><para>1. An absolute java.net.URL in externalForm. (ex: <ulink url="http://myhandlers.foo.com/handlerfile1.xml">http://myhandlers.foo.com/handlerfile1.xml</ulink>)</para><para>2. A relative path from the source file or class file. (ex: bar/handlerfile1.xml)</para></section>
<section id="JBossWS-UserGuide_Service_client_handlers"><title>Service client handlers</title><para>On the client side, handler can be configured using the @HandlerChain annotation on the SEI or dynamically using the API.</para><screen xml:space="preserve">      Service service = Service.create(wsdlURL, serviceName);
      Endpoint port = (Endpoint)service.getPort(Endpoint.class);
      
      BindingProvider bindingProvider = (BindingProvider)port;
      List&lt;Handler&gt; handlerChain = <emphasis role="bold">new</emphasis> ArrayList&lt;Handler&gt;();
      handlerChain.add(<emphasis role="bold">new</emphasis> LogHandler());
      handlerChain.add(<emphasis role="bold">new</emphasis> AuthorizationHandler());
      handlerChain.add(<emphasis role="bold">new</emphasis> RoutingHandler());
      bindingProvider.getBinding().setHandlerChain(handlerChain); // important!
</screen></section>
</section>
<section id="JBossWS-UserGuide_Message_Context"><title>Message Context</title><para>MessageContext is the super interface for all JAX-WS message contexts. It extends Map&lt;String,Object&gt; with additional methods and constants to manage a set of properties that enable handlers in a handler chain to share processing related state. For example, a handler may use the put method to insert a property in the message context that one or more other handlers in the handler chain may subsequently obtain via the get method.</para><para>Properties are scoped as either APPLICATION or HANDLER. All properties are available to all handlers for an instance of an MEP on a particular endpoint. E.g., if a logical handler puts a property in the message context, that property will also be available to any protocol handlers in the chain during the execution of an MEP instance. APPLICATION scoped properties are also made available to client applications (see section 4.2.1) and service endpoint implementations. The defaultscope for a property is HANDLER.</para><section id="JBossWS-UserGuide_Logical_Message_Context"><title>Logical Message Context</title><para><link linkend="JBossWS-UserGuide_Logical_Handler">Logical Handlers</link> are passed a message context of type LogicalMessageContext when invoked. LogicalMessageContext extends MessageContext with methods to obtain and modify the message payload, it does not provide access to the protocol specific aspects of amessage. A protocol binding defines what component of a message are available via a logical message context. The SOAP binding defines that a logical handler deployed in a SOAP binding can access the contents of the SOAP body but not the SOAP headers whereas the XML/HTTP binding defines that a logical handler can access the entire XML payload of a message.</para></section>
<section id="JBossWS-UserGuide_SOAP_Message_Context"><title>SOAP Message Context</title><para>SOAP handlers are passed a SOAPMessageContext when invoked. SOAPMessageContext extends MessageContext with methods to obtain and modify the SOAP message payload.</para></section>
</section>
<section id="JBossWS-UserGuide_Fault_Handling"><title>Fault Handling</title><para>An implementation may thow a SOAPFaultException</para><screen xml:space="preserve">   <emphasis role="bold">public</emphasis> <emphasis role="bold">void</emphasis> throwSoapFaultException()
   {
      SOAPFactory factory = SOAPFactory.newInstance();
      SOAPFault fault = factory.createFault("this is a fault string!", <emphasis role="bold">new</emphasis> QName("<ulink url="http://foo">http://foo</ulink>", "FooCode"));
      fault.setFaultActor("mr.actor");
      fault.addDetail().addChildElement("test");
      <emphasis role="bold">throw</emphasis> <emphasis role="bold">new</emphasis> SOAPFaultException(fault);
   }
</screen><para>or an application specific user exception</para><screen xml:space="preserve">   <emphasis role="bold">public</emphasis> <emphasis role="bold">void</emphasis> throwApplicationException() <emphasis role="bold">throws</emphasis> UserException
   {
      <emphasis role="bold">throw</emphasis> <emphasis role="bold">new</emphasis> UserException("validation", 123, "Some validation error");
   }
</screen><note><para><para><emphasis role="bold">Note</emphasis></para><para>In case of the latter JBossWS generates the required fault wrapper beans at runtime if they are not part of the deployment</para><para> </para></para></note>
</section>
<section id="JBossWS-UserGuide_JBossWS_Extensions"><title>JBossWS Extensions</title><para>This section describes propriatary JBoss extensions to JAX-WS, that works with all the supported stacks.</para><para> </para><section id="JBossWS-UserGuide_Proprietary_Annotations"><title>Proprietary Annotations</title><para>For the set of standard annotations, please have a look at <link linkend="chap_JBossWS-JAX-WSAnnotations">JAX-WS_Annotations</link>.</para><para> </para><section id="JBossWS-UserGuide_WebContext"><title>WebContext</title><screen xml:space="preserve">/**
 * Provides web context specific meta data to EJB based web service endpoints.
 *
 * @author <ulink url="mailto:thomas.diesler@jboss.org">thomas.diesler@jboss.org</ulink>
 * @since 26-Apr-2005
 */
@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = { ElementType.TYPE })
<emphasis role="bold">public</emphasis> @<emphasis role="bold">interface</emphasis> WebContext {
 
   /** 
    * The contextRoot element specifies the context root that the web service endpoint is deployed to.
    * If it is not specified it will be derived from the deployment short name.
    * 
    * Applies to server side port components only. 
    */
   String contextRoot() <emphasis role="bold">default</emphasis> "";
   
   /** 
    * The virtual hosts that the web service endpoint is deployed to.
    * 
    * Applies to server side port components only.
    */
   String[] virtualHosts() <emphasis role="bold">default</emphasis> {};
   
   /** 
    * Relative path that is appended to the contextRoot to form fully qualified
    * endpoint address for the web service endpoint.
    * 
    * Applies to server side port components only. 
    */
   String urlPattern() <emphasis role="bold">default</emphasis> "";
 
   /**
    * The authMethod is used to configure the authentication mechanism for the web service. 
    * As a prerequisite to gaining access to any web service which are protected by an authorization
    * constraint, a user must have authenticated using the configured mechanism.
    *
    * Legal values for this element are "BASIC", or "CLIENT-CERT".
    */
   String authMethod() <emphasis role="bold">default</emphasis> "";
 
   /**
    * The transportGuarantee specifies that the communication
    * between client and server should be NONE, INTEGRAL, or
    * CONFIDENTIAL. NONE means that the application does not require any
    * transport guarantees. A value of INTEGRAL means that the application
    * requires that the data sent between the client and server be sent in
    * such a way that it can't be changed in transit. CONFIDENTIAL means
    * that the application requires that the data be transmitted in a
    * fashion that prevents other entities from observing the contents of
    * the transmission. In most cases, the presence of the INTEGRAL or
    * CONFIDENTIAL flag will indicate that the use of SSL is required.
    */
   String transportGuarantee() <emphasis role="bold">default</emphasis> "";
 
   /**
    * A secure endpoint does not secure wsdl access by default.
    * Explicitly setting secureWSDLAccess overrides this behaviour.
    * 
    * Protect access to WSDL. See <ulink url="http://jira.jboss.org/jira/browse/JBWS-723">http://jira.jboss.org/jira/browse/JBWS-723</ulink>   
    */
   <emphasis role="bold">boolean</emphasis> secureWSDLAccess() <emphasis role="bold">default</emphasis> <emphasis role="bold">false</emphasis>;
}
</screen></section>
<section id="JBossWS-UserGuide_SecurityDomain"><title>SecurityDomain</title><screen xml:space="preserve">/**
 * Annotation for specifying the JBoss security domain for an EJB
 * 
 * @author &lt;a href="mailto:<ulink url="mailto:bill@jboss.org">bill@jboss.org</ulink>"&gt;Bill Burke&lt;/a&gt;
 **/
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
<emphasis role="bold">public</emphasis> @<emphasis role="bold">interface</emphasis> SecurityDomain
{
   /**
    * The required name for the security domain.
    * 
    * Do not use the JNDI name
    * 
    *    Good: "MyDomain"
    *    Bad:  "java:/jaas/MyDomain"
    */
   String value();
   
   /**
    * The name for the unauthenticated pricipal
    */
   String unauthenticatedPrincipal() <emphasis role="bold">default</emphasis> "";
</screen></section></section>
</section>
<section id="JBossWS-UserGuide_JAXB_Introductions"><title>JAXB Introductions</title><para>As Kohsuke Kawaguchi writes on <ulink url="http://weblogs.java.net/blog/kohsuke/archive/2007/07/binding_3rd_par.html">his blog</ulink>, one common complaint from the JAXB users is the lack of support for binding 3rd party classes. The scenario is this  you are trying to annotate your classes with JAXB annotations to make it XML bindable, but some of the classes are coming from libraries and JDK, and thus you cannot put necessary JAXB annotations on it.</para><para>To solve this JAXB has been designed to provide hooks for programmatic introduction of annotations to the runtime.</para><para>This is currently leveraged by the JBoss JAXB Introductions project, using which users can define annotations in XML and make JAXB see those as if those were in the class files (perhaps coming from 3rd party libraries).</para><para> </para><para>JAXB Introductions are currently supported in JBossWS-Native (server side only, since 3.0.2.GA) and JBossWS-CXF (both server and client side, since 3.2.1.GA).</para><para>Take a look at the <ulink url="http://community.jboss.org/docs/DOC-10075">JAXB Introductions page</ulink> on the wiki and at the examples in the sources.</para><para> </para></section>
</section>
<section id="JBossWS-UserGuide_Tools"><title>Tools</title><para>The JBossWS Web Service Framework provides unified tooling for all the supported stacks. This currently includes common JAX-WS tools for both contract-first and code-first development and common management tools.</para><section id="JBossWS-UserGuide_JAXWS_tools"><title>JAX-WS tools</title><para>Please refer to <link linkend="chap_JBossWS-JAX-WSTools">JBossWS_JAX-WS_Tools</link> for details. This covers directions on web service contract generation (bottom-up development) and consumption (top-down and client development).</para></section>
<section id="JBossWS-UserGuide_Management_tools"><title>Management tools</title><para>JBoss and its web service framework come with some tools allowing WS endpoint management.</para><para>Please refer the <link linkend="chap_JBossWS-Endpointmanagement">Endpoint management</link> page for an overview of the available tools. In particular the <link linkend="chap_JBossWS-Recordsmanagement">JBossWS - Records management</link> gives administrators a means of performing custom analysis of their web service traffic as well as exporting communication logs.</para></section>
<section id="JBossWS-UserGuide_Web_Service_console"><title>Web Service console</title><para>All supported stacks provide a web console for getting the list of the endpoints currently deployed on a given host as well as basic metrics regarding invocations to them. The console is available at <ulink url="http://localhost:8080/jbossws/services">http://localhost:8080/jbossws/services</ulink> assuming your application server is currently bound to localhost:8080.</para><para> </para></section>
</section>
<section id="JBossWS-UserGuide_Configuration"><title>Configuration</title><section id="JBossWS-UserGuide_Address_rewrite"><title>Address rewrite</title><para>JBossWS allows users to configure the soap:address attribute in the wsdl contract of deployed services as well as wsdl address in the web service console. [due to a known issue this does not currently work with JBossWS-Metro, see: <ulink url="https://jira.jboss.org/jira/browse/JBWS-2462">JBWS-2462</ulink>]</para><para> </para><para><emphasis role="bold">Server configuration options</emphasis></para><para> </para><para>There're few attributes in the jbossws deployers configuration (currently in jbossws.deployer/META-INF/stack-agnostic-jboss-beans.xml) controlling the way the soap:address attribute in the wsdl is rewritten.</para><screen xml:space="preserve">&lt;bean name="WSServerConfig" class="org.jboss.webservices.integration.config.ServerConfigImpl"&gt;
    &lt;property name="mbeanServer"&gt;&lt;inject bean="WSMBeanServerLocator" property="mbeanServer"/&gt;&lt;/property&gt;

    &lt;property name="webServiceHost"&gt;${jboss.bind.address}&lt;/property&gt;
    &lt;property name="modifySOAPAddress"&gt;true&lt;/property&gt;

    &lt;!--
      &lt;property name="webServiceSecurePort"&gt;8443&lt;/property&gt;
      &lt;property name="webServicePort"&gt;8080&lt;/property&gt;
    --&gt;
  &lt;/bean&gt;
</screen><para> </para><para>If the content of <emphasis>&lt;soap:address&gt;</emphasis> in the wsdl is a valid URL, JBossWS will not rewrite it unless <emphasis>modifySOAPAddress</emphasis> is true. If the content of <emphasis>&lt;soap:address&gt;</emphasis> is not a valid URL instead, JBossWS will always rewrite it using the attribute values given below. Please note that the variable <emphasis>${jboss.bind.address}</emphasis> can be used to set the address which the application is bound to at each startup.</para><para> </para><para>The webServiceSecurePort and webServicePort attributes are used to explicitly define the ports to be used for rewriting the SOAP address. If these attributes are not set, the ports will be identified by querying the list of installed connectors. If multiple connectors are found the port of the first connector is used.</para><para> </para><para><emphasis role="bold">Dynamic rewrite</emphasis></para><para> </para><para>When the application server is bound to multiple addresses or non-trivial real-world network architectures cause request for different external addresses to hit the same endpoint, a static rewrite of the soap:address may not be enough. JBossWS allows for both the soap:address in the wsdl and the wsdl address in the console to be rewritten with the host use in the client request. This way, users always get the right wsdl address assuming they're connecting to an instance having the endpoint they're looking for. To trigger this behaviour, the <emphasis role="bold">jbossws.undefined.host</emphasis> value has to be specified for the <emphasis>webServiceHost</emphasis> attribute.</para><screen xml:space="preserve">&lt;property name="webServiceHost"&gt;jbossws.undefined.host&lt;/property&gt;
&lt;property name="modifySOAPAddress"&gt;true&lt;/property&gt;</screen><para> </para><para>Of course, when a confidential transport address is required, the addresses are always rewritten using https protocol and the port currently configured for the https/ssl connector.</para></section>
</section></section></chapter>