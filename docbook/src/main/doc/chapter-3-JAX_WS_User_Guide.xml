<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="sid-3866716">
    
    <title>JAX-WS User Guide</title>
    <para>
      The
      <ulink url="http://www.jcp.org/en/jsr/detail?id=224">Java API for XML-Based Web Services (JAX-WS / JSR-224)</ulink>
      defines the mapping between WSDL and Java as well as the classes to be used for accessing webservices and publishing them. JBossWS implements the latest JAX-WS specification, hence users can reference it for any vendor agnostic webservice usage need. Below is a brief overview of the most basic functionalities.
    </para>
    <section id="sid-3866716_JAX-WSUserGuide-WebServiceEndpoints">
      
      <title>Web Service Endpoints</title>
      <para>
        JAX-WS simplifies the development model for a web service endpoint a great deal. In short, an endpoint implementation bean is annotated with JAX-WS annotations and deployed to the server. The server automatically generates and publishes the abstract contract (i.e. wsdl+schema) for client consumption. All marshalling/unmarshalling is delegated to
        <ulink url="http://www.jcp.org/en/jsr/summary?id=jaxb">JAXB</ulink>
        .
      </para>
      <section id="sid-3866716_JAX-WSUserGuide-PlainoldJavaObject%28POJO%29">
        
        <title>Plain old Java Object (POJO)</title>
        <para>
          Let's take a look at simple POJO endpoint implementation. All endpoint associated metadata is provided via
          <ulink url="http://www.jcp.org/en/jsr/summary?id=181">JSR-181</ulink>
          annotations
        </para>
        <informalexample>
          <programlisting>@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean01
{
   @WebMethod
   public String echo(String input)
   {
      ...
   }
}</programlisting>
        </informalexample>
        <section id="sid-3866716_JAX-WSUserGuide-Theendpointasawebapplication">
          
          <title>The endpoint as a web application</title>
          <para>
            A JAX-WS java service endpoint (JSE) is deployed as a web application. Here is a sample
            <emphasis role="italics">web.xml</emphasis>
            descriptor:
          </para>
          <informalexample>
            <programlisting>&lt;web-app ...&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>
          </informalexample>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-Packagingtheendpoint">
          
          <title>Packaging the endpoint</title>
          <para>
            A JSR-181 java service endpoint (JSE) is packaged as a web application in a
            <emphasis role="italics">war</emphasis>
            file.
          </para>
          <informalexample>
            <programlisting>&lt;war warfile="${build.dir}/libs/jbossws-samples-jsr181pojo.war" webxml="${build.resources.dir}/samples/jsr181pojo/WEB-INF/web.xml"&gt;
  &lt;classes dir="${build.dir}/classes"&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181pojo/JSEBean01.class"/&gt;
  &lt;/classes&gt;
&lt;/war&gt;</programlisting>
          </informalexample>
          <para>Note, only the endpoint implementation bean and web.xml are required.</para>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-AccessingthegeneratedWSDL">
          
          <title>Accessing the generated WSDL</title>
          <para>A successfully deployed service endpoint will show up in the JBoss AS managent console. You can get the deployed endpoint wsdl address there too.</para>
          <important>
            <para>Note, it is also possible to generate the abstract contract off line  using JBossWS tools. For details of that please see Bottom-Up (Java to  WSDL).</para>
          </important>
        </section>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-EJB3StatelessSessionBean%28SLSB%29">
        
        <title>EJB3 Stateless Session Bean (SLSB)</title>
        <para>The JAX-WS programming model supports the same set of annotations on EJB3 stateless session beans as on POJO endpoints.</para>
        <informalexample>
          <programlisting>@Stateless
@Remote(EJB3RemoteInterface.class)
@RemoteBinding(jndiBinding = "/ejb3/EJB3EndpointInterface")

@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class EJB3Bean01 implements EJB3RemoteInterface
{
   @WebMethod
   public String echo(String input)
   {
      ...
   }
}</programlisting>
        </informalexample>
        <para>Above you see an EJB-3.0 stateless session bean that exposes one method both on the remote interface and as an endpoint operation.</para>
        <section id="sid-3866716_JAX-WSUserGuide-Packagingtheendpointx">
          
          <title>Packaging the endpoint</title>
          <para>A JSR-181 EJB service endpoint is packaged as an ordinary ejb deployment.</para>
          <informalexample>
            <programlisting>&lt;jar jarfile="${build.dir}/libs/jbossws-samples-jsr181ejb.jar"&gt;
  &lt;fileset dir="${build.dir}/classes"&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3Bean01.class"/&gt;
    &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3RemoteInterface.class"/&gt;
  &lt;/fileset&gt;
&lt;/jar&gt;</programlisting>
          </informalexample>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-AccessingthegeneratedWSDLx">
          
          <title>Accessing the generated WSDL</title>
          <para>A successfully deployed service endpoint will show up in the JBoss AS  managent console. You can get the deployed endpoint wsdl address there  too.</para>
          <important>
            <para>Note,  it is also possible to generate the abstract contract off line  using  JBossWS tools. For details of that please see Bottom-Up (Java to  WSDL).</para>
          </important>
        </section>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-EndpointProvider">
        
        <title>Endpoint Provider</title>
        <para>JAX-WS services typically implement a native Java service endpoint interface (SEI), perhaps mapped from a WSDL port type, either directly or via the use of annotations.</para>
        <para>Java SEIs provide a high level Java-centric abstraction that hides the details of converting between Java objects and their XML representations for use in XML-based messages. However, in some cases it is desirable for services to be able to operate at the XML message level. The Provider interface offers an alternative to SEIs and may be implemented by services wishing to work at the XML message level.</para>
        <para>A Provider based service instances invoke method is called for each message received for the service.</para>
        <informalexample>
          <programlisting>@WebServiceProvider(wsdlLocation = "WEB-INF/wsdl/Provider.wsdl")
@ServiceMode(value = Service.Mode.PAYLOAD)
public class ProviderBeanPayload implements Provider&lt;Source&gt;
{
   public Source invoke(Source req)
   {
      // Access the entire request PAYLOAD and return the response PAYLOAD
   }
}</programlisting>
        </informalexample>
        <para>
          Note,
          <code>Service.Mode.PAYLOAD</code>
          is the default and does not have to be declared explicitly. You can also use
          <code>Service.Mode.MESSAGE</code>
          to access the entire SOAP message (i.e. with
          <code>MESSAGE</code>
          the Provider can also see SOAP Headers)
        </para>
        <para>
          The abstract contract for a provider endpoint cannot be derived/generated automatically. Therefore it is necessary to specify the
          <emphasis role="italics">wsdlLocation</emphasis>
          with the
          <code>@</code>
          <code>WebServiceProvider</code>
          annotation.
        </para>
      </section>
    </section>
    <section id="sid-3866716_JAX-WSUserGuide-WebServiceClients">
      
      <title>Web Service Clients</title>
      <section id="sid-3866716_JAX-WSUserGuide-Service">
        
        <title>Service</title>
        <para>
          <code>Service</code>
          is an abstraction that represents a WSDL service. A WSDL service is a collection of related ports, each of which consists of a port type bound to a particular protocol and available at a particular endpoint address.
        </para>
        <para>For most clients, you will start with a set of stubs generated from the WSDL. One of these will be the service, and you will create objects of that class in order to work with the service (see "static case" below).</para>
        <section id="sid-3866716_JAX-WSUserGuide-ServiceUsage">
          
          <title>Service Usage</title>
          <section id="sid-3866716_JAX-WSUserGuide-Staticcase">
            
            <title>Static case</title>
            <para>
              Most clients will start with a WSDL file, and generate some stubs using JBossWS tools like
              <emphasis role="italics">wsconsume</emphasis>
              .  This usually gives a mass of files, one of which is the top of the tree.  This is the service implementation class.
            </para>
            <para>
              The generated implementation class can be recognised as it will have two public constructors, one with no arguments and one with two arguments, representing the wsdl location (a
              <code>java.net.URL</code>
              ) and the service name (a
              <code>javax.xml.namespace.QName</code>
              ) respectively.
            </para>
            <para>
              Usually you will use the no-argument constructor. In this case the WSDL location and service name are those found in the WSDL. These are set implicitly from the
              <code>@WebServiceClient</code>
              annotation that decorates the generated class.
            </para>
            <para>The following code snippet shows the generated constructors from the generated class:</para>
            <informalexample>
              <programlisting>// Generated Service Class

@WebServiceClient(name="StockQuoteService", targetNamespace="http://example.com/stocks", wsdlLocation="http://example.com/stocks.wsdl")
public class StockQuoteService extends javax.xml.ws.Service
{
   public StockQuoteService()
   {
      super(new URL("http://example.com/stocks.wsdl"), new QName("http://example.com/stocks", "StockQuoteService"));
   }

   public StockQuoteService(String wsdlLocation, QName serviceName)
   {
      super(wsdlLocation, serviceName);
   }

   ...
}</programlisting>
            </informalexample>
            <para>
              Section Dynamic Proxy explains how to obtain a port from the service and how to invoke an operation on the port. If you need to work with the XML payload directly or with the XML representation of the entire SOAP message, have a look at
              <code>Dispatch</code>
              .
            </para>
          </section>
          <section id="sid-3866716_JAX-WSUserGuide-Dynamiccase">
            
            <title>Dynamic case</title>
            <para>
              In the dynamic case, when nothing is generated, a web service client uses
              <code>Service.create</code>
              to create Service instances, the following code illustrates this process.
            </para>
            <informalexample>
              <programlisting>URL wsdlLocation = new URL("http://example.org/my.wsdl");
QName serviceName = new QName("http://example.org/sample", "MyService");
Service service = Service.create(wsdlLocation, serviceName);</programlisting>
            </informalexample>
          </section>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-HandlerResolver">
          
          <title>Handler Resolver</title>
          <para>
            JAX-WS provides a flexible plug-in framework for message processing modules, known as handlers, that may be used to extend the capabilities of a JAX-WS runtime system. Handler Framework describes the handler framework in detail. A Service instance provides access to a
            <code>HandlerResolver</code>
            via a pair of
            <code>getHandlerResolver</code>
            /
            <code>setHandlerResolver</code>
            methods that may be used to configure a set of handlers on a per-service, per-port or per-protocol binding basis.
          </para>
          <para>When a Service instance is used to create a proxy or a Dispatch instance then the handler resolver currently registered with the service is used to create the required handler chain. Subsequent changes to the handler resolver configured for a Service instance do not affect the handlers on previously created proxies, or Dispatch instances.</para>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-Executor">
          
          <title>Executor</title>
          <para>
            Service instances can be configured with a
            <code>java.util.concurrent.Executor</code>
            . The executor will then be used to invoke any asynchronous callbacks requested by the application. The
            <code>setExecutor</code>
            and
            <code>getExecutor</code>
            methods of
            <code>Service</code>
            can be used to modify and retrieve the executor configured for a service.
          </para>
        </section>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-DynamicProxy">
        
        <title>Dynamic Proxy</title>
        <para>
          You can create an instance of a client proxy using one of
          <code>getPort</code>
          methods on the
          <code>Service</code>
          .
        </para>
        <informalexample>
          <programlisting>/**
 * The getPort method returns a proxy. A service client
 * uses this proxy to invoke operations on the target
 * service endpoint. The &lt;code&gt;serviceEndpointInterface&lt;/code&gt;
 * specifies the service endpoint interface that is supported by
 * the created dynamic proxy instance.
 **/
public &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
{
   ...
}

/**
 * The getPort method returns a proxy. The parameter
 * &lt;code&gt;serviceEndpointInterface&lt;/code&gt; specifies the service
 * endpoint interface that is supported by the returned proxy.
 * In the implementation of this method, the JAX-WS
 * runtime system takes the responsibility of selecting a protocol
 * binding (and a port) and configuring the proxy accordingly.
 * The returned proxy should not be reconfigured by the client.
 *
 **/
public &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)
{
   ...
}</programlisting>
        </informalexample>
        <para>The service endpoint interface (SEI) is usually generated using tools. For details see Top Down (WSDL to Java)</para>
        <para>A generated static Service usually also offers typed methods to get ports. These methods also return dynamic proxies that implement the SEI.</para>
        <informalexample>
          <programlisting>@WebServiceClient(name = "TestEndpointService", targetNamespace = "http://org.jboss.ws/wsref",
   wsdlLocation = "http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl")

public class TestEndpointService extends Service
{
    ...

    public TestEndpointService(URL wsdlLocation, QName serviceName) {
        super(wsdlLocation, serviceName);
    }

    @WebEndpoint(name = "TestEndpointPort")
    public TestEndpoint getTestEndpointPort()
    {
        return (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
    }
}</programlisting>
        </informalexample>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-WebServiceRef">
        
        <title>WebServiceRef</title>
        <para>
          The
          <code>@WebServiceRef</code>
          annotation is used to declare a reference to a Web service. It follows the resource pattern exemplified by the
          <code>javax.annotation.Resource</code>
          annotation in
          <ulink url="http://www.jcp.org/en/jsr/summary?id=250">JSR-250</ulink>
          .
        </para>
        <para>There are two uses to the WebServiceRef annotation:</para>
        <orderedlist>
          <listitem>
            <para>To define a reference whose type is a generated service class. In this case, the type and value element will both refer to the generated service class type. Moreover, if the reference type can be inferred by the field/method declaration the annotation is applied to, the type and value elements MAY have the default value (Object.class, that is). If the type cannot be inferred, then at least the type element MUST be present with a non-default value.</para>
          </listitem>
          <listitem>
            <para>To define a reference whose type is a SEI. In this case, the type element MAY be present with its default value if the type of the reference can be inferred from the annotated field/method declaration, but the value element MUST always be present and refer to a generated service class type (a subtype of javax.xml.ws.Service). The wsdlLocation element, if present, overrides theWSDL location information specified in the WebService annotation of the referenced generated service class.</para>
            <informalexample>
              <programlisting>public class EJB3Client implements EJB3Remote
{
   @WebServiceRef
   public TestEndpointService service4;

   @WebServiceRef
   public TestEndpoint port3;</programlisting>
            </informalexample>
          </listitem>
        </orderedlist>
        <section id="sid-3866716_JAX-WSUserGuide-WebServiceRefcustomization">
          
          <title>WebServiceRef customization</title>
          <para>We offer a number of overrides and extensions to the WebServiceRef annotation. These include</para>
          <itemizedlist>
            <listitem>
              <para>define the port that should be used to resolve a container-managed port</para>
            </listitem>
            <listitem>
              <para>define default Stub property settings for Stub objects</para>
            </listitem>
            <listitem>
              <para>
                define the URL of a final WSDL document to be used
                
                Example:
              </para>
            </listitem>
          </itemizedlist>
          <informalexample>
            <programlisting>  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;wsdl-override&gt;file:/wsdlRepository/organization-service.wsdl&lt;/wsdl-override&gt;
  &lt;/service-ref&gt;

  &lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;config-name&gt;Secure Client Config&lt;/config-name&gt;
   &lt;config-file&gt;META-INF/jbossws-client-config.xml&lt;/config-file&gt;
   &lt;handler-chain&gt;META-INF/jbossws-client-handlers.xml&lt;/handler-chain&gt;
  &lt;/service-ref&gt;
 
  &lt;service-ref&gt;
   &lt;service-ref-name&gt;SecureService&lt;/service-ref-name&gt;
   &lt;service-impl-class&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpointService&lt;/service-impl-class&gt;
   &lt;service-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointService&lt;/service-qname&gt;
    &lt;port-component-ref&gt;
     &lt;service-endpoint-interface&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpoint&lt;/service-endpoint-interface&gt;
     &lt;port-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointPort&lt;/port-qname&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;javax.xml.ws.security.auth.username&lt;/prop-name&gt;
      &lt;prop-value&gt;kermit&lt;/prop-value&gt;
     &lt;/stub-property&gt;
     &lt;stub-property&gt;
      &lt;prop-name&gt;javax.xml.ws.security.auth.password&lt;/prop-name&gt;
      &lt;prop-value&gt;thefrog&lt;/prop-value&gt;
     &lt;/stub-property&gt;
   &lt;/port-component-ref&gt;
  &lt;/service-ref&gt;</programlisting>
          </informalexample>
          <para>
            For details please see
            <emphasis role="italics">
              <ulink url="http://www.jboss.org/j2ee/dtd/service-ref_5_0.dtd">service-ref_5_0.dtd</ulink>
            </emphasis>
            .
          </para>
        </section>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-Dispatch">
        
        <title>Dispatch</title>
        <para>XMLWeb Services use XML messages for communication between services and service clients. The higher level JAX-WS APIs are designed to hide the details of converting between Java method invocations and the corresponding XML messages, but in some cases operating at the XML message level is desirable. The Dispatch interface provides support for this mode of interaction.</para>
        <para>
          <code>Dispatch</code>
          supports two usage modes, identified by the constants
          <code>javax.xml.ws.Service.Mode.MESSAGE</code>
          and
          <code>javax.xml.ws.Service.Mode.PAYLOAD</code>
          respectively:
        </para>
        <para>
          <emphasis role="strong">
            <emphasis role="italics">Message</emphasis>
          </emphasis>
          In this mode, client applications work directly with protocol-specific message structures. E.g., when used with a SOAP protocol binding, a client application would work directly with a SOAP message.
        </para>
        <para>
          <emphasis role="strong">
            <emphasis role="italics">Message Payload</emphasis>
          </emphasis>
          In this mode, client applications work with the payload of messages rather than the messages themselves. E.g., when used with a SOAP protocol binding, a client application would work with the contents of the SOAP Body rather than the SOAP message as a whole.
        </para>
        <para>Dispatch is a low level API that requires clients to construct messages or message payloads as XML and requires an intimate knowledge of the desired message or payload structure. Dispatch is a generic class that supports input and output of messages or message payloads of any type.</para>
        <informalexample>
          <programlisting>Service service = Service.create(wsdlURL, serviceName);
Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);

String payload = "&lt;ns1:ping xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
dispatch.invokeOneWay(new StreamSource(new StringReader(payload)));

payload = "&lt;ns1:feedback xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
Source retObj = (Source)dispatch.invoke(new StreamSource(new StringReader(payload)));</programlisting>
        </informalexample>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-AsynchronousInvocations">
        
        <title>Asynchronous Invocations</title>
        <para>
          The
          <code>BindingProvider</code>
          interface represents a component that provides a protocol binding for use by clients, it is implemented by proxies and is extended by the
          <code>Dispatch</code>
          interface.
        </para>
        <para>
          <code>BindingProvider</code>
          instances may provide asynchronous operation capabilities. When used, asynchronous operation invocations are decoupled from the
          <code>BindingProvider</code>
          instance at invocation time such that the response context is not updated when the operation completes. Instead a separate response context is made available using the
          <code>Response</code>
          interface.
        </para>
        <informalexample>
          <programlisting>public void testInvokeAsync() throws Exception
{
   URL wsdlURL = new URL("http://" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
   QName serviceName = new QName(targetNS, "TestEndpointService");
   Service service = Service.create(wsdlURL, serviceName);
   TestEndpoint port = service.getPort(TestEndpoint.class);
   Response response = port.echoAsync("Async");
   // access future
   String retStr = (String) response.get();
   assertEquals("Async", retStr);
}</programlisting>
        </informalexample>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-OnewayInvocations">
        
        <title>Oneway Invocations</title>
        <para>
          <code>@Oneway</code>
          indicates that the given web method has only an input message and no output. Typically, a oneway method returns the thread of control to the calling application prior to executing the actual business method.
        </para>
        <informalexample>
          <programlisting>@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class PingEndpointImpl
{
   private static String feedback;
  
   @WebMethod
   @Oneway
   publicvoid ping()
   {
      log.info("ping");
      feedback = "ok";
   }
  
   @WebMethod
   public String feedback()
   {
      log.info("feedback");
      return feedback;
   }
}</programlisting>
        </informalexample>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-TimeoutConfiguration">
        
        <title>Timeout Configuration</title>
        <para>There are two properties to configure the http connection timeout and client receive time out:</para>
        <informalexample>
          <programlisting>public void testConfigureTimeout() throws Exception
{
   //Set timeout until a connection is established
   ((BindingProvider)port).getRequestContext().put("javax.xml.ws.client.connectionTimeout", "6000");

   //Set timeout until the response is received
   ((BindingProvider) port).getRequestContext().put("javax.xml.ws.client.receiveTimeout", "1000");

   port.echo("testTimeout");
}</programlisting>
        </informalexample>
      </section>
    </section>
    <section id="sid-3866716_JAX-WSUserGuide-CommonAPI">
      
      <title>Common API</title>
      <para>This sections describes concepts that apply equally to Web Service Endpoints and Web Service Clients.</para>
      <section id="sid-3866716_JAX-WSUserGuide-HandlerFramework">
        
        <title>Handler Framework</title>
        <para>The handler framework is implemented by a JAX-WS protocol binding in both client and server side runtimes. Proxies, and Dispatch instances, known collectively as binding providers, each use protocol bindings to bind their abstract functionality to specific protocols.</para>
        <para>Client and server-side handlers are organized into an ordered list known as a handler chain. The handlers within a handler chain are invoked each time a message is sent or received. Inbound messages are processed by handlers prior to binding provider processing. Outbound messages are processed by handlers after any binding provider processing.</para>
        <para>Handlers are invoked with a message context that provides methods to access and modify inbound and outbound messages and to manage a set of properties. Message context properties may be used to facilitate communication between individual handlers and between handlers and client and service implementations. Different types of handlers are invoked with different types of message context.</para>
        <section id="sid-3866716_JAX-WSUserGuide-LogicalHandler">
          
          <title>Logical Handler</title>
          <para>
            Handlers that only operate on message context properties and message payloads. Logical handlers are protocol agnostic and are unable to affect protocol specific parts of a message. Logical handlers are handlers that implement
            <code>javax.xml.ws.handler.LogicalHandler</code>
            .
          </para>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-ProtocolHandler">
          
          <title>Protocol Handler</title>
          <para>
            Handlers that operate on message context properties and protocol specific messages. Protocol handlers are specific to a particular protocol and may access and change protocol specific aspects of a message. Protocol handlers are handlers that implement any interface derived from
            <code>javax.xml.ws.handler.Handler</code>
            except
            <code>javax.xml.ws.handler.LogicalHandler</code>
            .
          </para>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-Serviceendpointhandlers">
          
          <title>Service endpoint handlers</title>
          <para>
            On the service endpoint, handlers are defined using the
            <code>@HandlerChain</code>
            annotation.
          </para>
          <informalexample>
            <programlisting>@WebService
@HandlerChain(file = "jaxws-server-source-handlers.xml")
public class SOAPEndpointSourceImpl
{
   ...
}</programlisting>
          </informalexample>
          <para>The location of the handler chain file supports 2 formats</para>
          <para>
            1. An absolute java.net.URL in externalForm. (ex:
            <ulink url="http://myhandlers.foo.com/handlerfile1.xml"/>
            )
          </para>
          <para>2. A relative path from the source file or class file. (ex: bar/handlerfile1.xml)</para>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-Serviceclienthandlers">
          
          <title>Service client handlers</title>
          <para>
            On the client side, handler can be configured using the
            <code>@HandlerChain</code>
            annotation on the SEI or dynamically using the API.
          </para>
          <informalexample>
            <programlisting>Service service = Service.create(wsdlURL, serviceName);
Endpoint port = (Endpoint)service.getPort(Endpoint.class);
     
BindingProvider bindingProvider = (BindingProvider)port;
List&lt;Handler&gt; handlerChain = new ArrayList&lt;Handler&gt;();
handlerChain.add(new LogHandler());
handlerChain.add(new AuthorizationHandler());
handlerChain.add(new RoutingHandler());
bindingProvider.getBinding().setHandlerChain(handlerChain); // important!</programlisting>
          </informalexample>
        </section>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-MessageContext">
        
        <title>Message Context</title>
        <para>
          <code>MessageContext</code>
          is the super interface for all JAX-WS message contexts. It extends
          <code>Map&lt;String,Object&gt;</code>
          with additional methods and constants to manage a set of properties that enable handlers in a handler chain to share processing related state. For example, a handler may use the put method to insert a property in the message context that one or more other handlers in the handler chain may subsequently obtain via the get method.
        </para>
        <para>Properties are scoped as either APPLICATION or HANDLER. All properties are available to all handlers for an instance of an MEP on a particular endpoint. E.g., if a logical handler puts a property in the message context, that property will also be available to any protocol handlers in the chain during the execution of an MEP instance. APPLICATION scoped properties are also made available to client applications (see section 4.2.1) and service endpoint implementations. The defaultscope for a property is HANDLER.</para>
        <section id="sid-3866716_JAX-WSUserGuide-LogicalMessageContext">
          
          <title>Logical Message Context</title>
          <para>
            Logical Handlers are passed a message context of type
            <code>LogicalMessageContext</code>
            when invoked.
            <code>LogicalMessageContext</code>
            extends
            <code>MessageContext</code>
            with methods to obtain and modify the message payload, it does not provide access to the protocol specific aspects of amessage. A protocol binding defines what component of a message are available via a logical message context. The SOAP binding defines that a logical handler deployed in a SOAP binding can access the contents of the SOAP body but not the SOAP headers whereas the XML/HTTP binding defines that a logical handler can access the entire XML payload of a message.
          </para>
        </section>
        <section id="sid-3866716_JAX-WSUserGuide-SOAPMessageContext">
          
          <title>SOAP Message Context</title>
          <para>
            SOAP handlers are passed a
            <code>SOAPMessageContext</code>
            when invoked.
            <code>SOAPMessageContext</code>
            extends
            <code>MessageContext</code>
            with methods to obtain and modify the SOAP message payload.
          </para>
        </section>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-FaultHandling">
        
        <title>Fault Handling</title>
        <para>
          An implementation may thow a
          <code>SOAPFaultException</code>
        </para>
        <informalexample>
          <programlisting>public void throwSoapFaultException()
{
   SOAPFactory factory = SOAPFactory.newInstance();
   SOAPFault fault = factory.createFault("this is a fault string!", new QName("http://foo", "FooCode"));
   fault.setFaultActor("mr.actor");
   fault.addDetail().addChildElement("test");
   thrownew SOAPFaultException(fault);
}</programlisting>
        </informalexample>
        <para>or an application specific user exception</para>
        <informalexample>
          <programlisting>public void throwApplicationException() throws UserException
{
   thrownew UserException("validation", 123, "Some validation error");
}</programlisting>
        </informalexample>
        <important>
          <para>In case of the latter, JBossWS generates the required fault wrapper beans at runtime if they are not part of the deployment</para>
        </important>
      </section>
    </section>
    <section id="sid-3866716_JAX-WSUserGuide-JAXWSAnnotations">
      
      <title>WS Annotations</title>
      <para>
        For details, see
        <ulink url="http://www.jcp.org/en/jsr/detail?id=224">JSR-224 - Java API for XML-Based Web Services (JAX-WS) 2.2</ulink>
      </para>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.ServiceMode">
        
        <title>javax.xml.ws.ServiceMode</title>
        <para>
          The
          <code>ServiceMode</code>
          annotation is used to specify the mode for a provider class, i.e. whether a provider wants to have access to protocol message  payloads (e.g. a SOAP body) or the entire protocol messages (e.g. a SOAP  envelope).
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.WebFault">
        
        <title>javax.xml.ws.WebFault</title>
        <para>
          The
          <code>WebFault</code>
          annotation is used when mapping WSDL faults to Java  exceptions, see section 2.5. It is used to capture the name of the fault  element used when marshalling the JAXB type generated from the global  element referenced by the WSDL fault message. It can also be used to  customize the mapping of service specific exceptions to WSDL faults.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.RequestWrapper">
        
        <title>javax.xml.ws.RequestWrapper</title>
        <para>
          The
          <code>RequestWrapper</code>
          annotation is applied to the methods of an SEI. It is  used to capture the JAXB generated request wrapper bean and the element  name and namespace for marshalling / unmarshalling the bean. The default  value of localName element is the operationName as defined in
          <code>WebMethod</code>
          annotation and the default value for the targetNamespace element is the  target namespace of the SEI.When starting from Java, this annotation is  used to resolve overloading conflicts in document literal mode. Only  the className element is required in this case.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.ResponseWrapper">
        
        <title>javax.xml.ws.ResponseWrapper</title>
        <para>
          The
          <code>ResponseWrapper</code>
          annotation is applied to the methods of an SEI. It is  used to capture the JAXB generated response wrapper bean and the element  name and namespace for marshalling / unmarshalling the bean. The  default value of the localName element is the operationName as defined  in the
          <code>WebMethod</code>
          appended with ”Response” and the default value of the  targetNamespace element is the target namespace of the SEI. When  starting from Java, this annotation is used to resolve overloading  conflicts in document literal mode. Only the className element is  required in this case.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.WebServiceClient">
        
        <title>javax.xml.ws.WebServiceClient</title>
        <para>
          The
          <code>WebServiceClient</code>
          annotation is specified on a generated service class  (see 2.7). It is used to associate a class with a specific Web service,  identify by a URL to a WSDL document and the qualified name of a  wsdl:service element.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.WebEndpoint">
        
        <title>javax.xml.ws.WebEndpoint</title>
        <para>
          The
          <code>WebEndpoint</code>
          annotation is specified on the getPortName() methods of a  generated service class (see 2.7). It is used to associate a get method  with a specific wsdl:port, identified by its local name (a NCName).
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.WebServiceProvider">
        
        <title>javax.xml.ws.WebServiceProvider</title>
        <para>
          The
          <code>WebServiceProvider</code>
          annotation is specified on classes that implement a  strongly typed
          <code>javax.xml.ws.Provider</code>
          . It is used to declare that a  class that satisfies the requirements for a provider (see 5.1) does  indeed define a Web service endpoint, much like the
          <code>WebService</code>
          annotation does for SEI-based endpoints.
        </para>
        <para>
          The
          <code>WebServiceProvider</code>
          and
          <code>WebService</code>
          annotations are mutually exclusive.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.BindingType">
        
        <title>javax.xml.ws.BindingType</title>
        <para>
          The
          <code>BindingType</code>
          annotation is applied to an endpoint implementation class.  It specifies the binding to use when publishing an endpoint of this  type.
        </para>
        <para>
          The default binding for an endpoint is the SOAP 1.1/HTTP one.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.WebServiceRef">
        
        <title>javax.xml.ws.WebServiceRef</title>
        <para>
          The
          <code>WebServiceRef</code>
          annotation is used to declare a reference to a Web  service. It follows the resource pattern exemplified by the
          <code>javax.annotation.Resource</code>
          annotation in JSR-250 [32]. The
          <code>WebServiceRef</code>
          annotation is required to be honored when running on the Java EE 5  platform, where it is subject to the common resource injection rules  described by the platform specification [33].
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.WebServiceRefs">
        
        <title>javax.xml.ws.WebServiceRefs</title>
        <para>
          The
          <code>WebServiceRefs</code>
          annotation is used to declare multiple references to Web  services on a single class. It is necessary to work around the limition  against specifying repeated annotations of the same type on any given  class, which prevents listing multiple
          <code>javax.ws.WebServiceRef</code>
          annotations one after the other. This annotation follows the resource  pattern exemplified by the
          <code>javax.annotation.Resources</code>
          annotation in  JSR-250.
        </para>
        <para>
          Since no name and type can be inferred in this case, each
          <code>WebServiceRef</code>
          annotation inside a WebServiceRefs MUST contain name and  type elements with non-default values. The
          <code>WebServiceRef</code>
          annotation is  required to be honored when running on the Java EE 5 platform, where it  is subject to the common resource injection rules described by the  platform specification.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.Action">
        
        <title>javax.xml.ws.Action</title>
        <para>
          The
          <code>Action</code>
          annotation is applied to the methods of a SEI. It used to  generate the wsa:Action on wsdl:input and wsdl:output of each wsdl:operation mapped from the annotated methods.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.xml.ws.FaultAction">
        
        <title>javax.xml.ws.FaultAction</title>
        <para>
          The
          <code>FaultAction</code>
          annotation is used within the
          <code>Action</code>
          annotation to generate  the wsa:Action element on the wsdl:fault element of each wsdl:operation  mapped from the annotated methods.
          
        </para>
      </section>
    </section>
    <section id="sid-3866716_JAX-WSUserGuide-JSR181Annotations">
      
      <title>181 Annotations</title>
      <para>JSR-181 defines the syntax and semantics of Java Web Service (JWS) metadata and default values.</para>
      <para>
        For details, see
        <ulink url="http://www.jcp.org/en/jsr/detail?id=181">JSR 181 - Web Services Metadata for the Java Platform</ulink>
        .
        
      </para>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.WebService">
        
        <title>javax.jws.WebService</title>
        <para>
          Marks a Java class as implementing a Web Service, or a Java interface as defining a Web Service interface.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.WebMethod">
        
        <title>javax.jws.WebMethod</title>
        <para>
          Customizes a method that is exposed as a Web Service operation.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.OneWay">
        
        <title>javax.jws.OneWay</title>
        <para>
          Indicates  that the given web method has only an input message and no output.  Typically, a oneway method returns the thread of control to the calling  application prior to executing the actual business method. A JSR-181  processor is REQUIRED to report an error if an operation marked
          <code>@Oneway</code>
          has a return value, declares any checked exceptions or has any INOUT or  OUT parameters.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.WebParam">
        
        <title>javax.jws.WebParam</title>
        <para>
          Customizes the mapping of an individual parameter to a Web Service message part and XML element.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.WebResult">
        
        <title>javax.jws.WebResult</title>
        <para>
          Customizes the mapping of the return value to a WSDL part and XML element.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.SOAPBinding">
        
        <title>javax.jws.SOAPBinding</title>
        <para>Specifies the mapping of the Web Service onto the SOAP message protocol.</para>
        <para>
          The
          <code>SOAPBinding</code>
          annotation has a target of
          <code>TYPE</code>
          and
          <code>METHOD</code>
          . The annotation  may be placed on a method if and only if the
          <code>SOAPBinding.style</code>
          is
          <code>DOCUMENT</code>
          . Implementations MUST report an error if the
          <code>SOAPBinding</code>
          annotation is placed on a method with a
          <code>SOAPBinding.style</code>
          of
          <code>RPC</code>
          .  Methods that do not have a
          <code>SOAPBinding</code>
          annotation accept the
          <code>SOAPBinding</code>
          behavior defined on the type.
          
        </para>
      </section>
      <section id="sid-3866716_JAX-WSUserGuide-javax.jws.HandlerChain">
        
        <title>javax.jws.HandlerChain</title>
        <para>
          The
          <code>@HandlerChain</code>
          annotation associates the Web Service with an externally defined handler chain.
        </para>
        <para>
          It is an error to combine this annotation with the
          <code>@SOAPMessageHandlers</code>
          annotation.
        </para>
        <para>
          The
          <code>@HandlerChain</code>
          annotation MAY be present on the endpoint interface and  service implementation bean. The service implementation bean's
          <code>@HandlerChain</code>
          is used if
          <code>@HandlerChain</code>
          is present on both.
        </para>
        <para>
          The
          <code>@HandlerChain</code>
          annotation MAY be specified on the type only. The annotation target includes
          <code>METHOD</code>
          and
          <code>FIELD</code>
          for use by JAX-WS-2.x.
        </para>
      </section>
    </section>
  </chapter>
